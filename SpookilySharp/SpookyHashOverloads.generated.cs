// SpookyHashOverloads.generated.cs
//
// Generated File. DO NOT EDIT THIS FILE. Edit SpookyHashOverloads.tt to change the produced file.
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Security;

namespace SpookilySharp
{
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="SByte"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public unsafe void Update(SByte message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(SByte) - 1)) == 0) && _remainder + sizeof(SByte) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(SByte*)((byte*)uptr + _remainder) = message;
                _length += sizeof(SByte);
                _remainder += sizeof(SByte);
            }
            else
                Update(&message, sizeof(SByte));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="SByte"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="SByte"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        public void Update(SByte[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(SByte[] message, int startIndex, int length)
        {
            fixed(SByte* ptr = message)
                Update(ptr + startIndex, length * sizeof(SByte));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="SByte"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(SByte[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{SByte}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(IEnumerable<SByte> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as SByte[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<SByte> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(SByte[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(SByte* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(SByte), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="SByte"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="SByte"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(SByte[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="SByte"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="SByte"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(SByte[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="SByte"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="SByte"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(SByte[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="SByte"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(SByte[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(SByte[] message, int startIndex, int length, ulong seed)
        {
            fixed(SByte* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(SByte), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="SByte"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="SByte"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(SByte[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="SByte"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="SByte"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(SByte[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="SByte"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(SByte[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="SByte"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(SByte[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(SByte[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="SByte"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="SByte"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(SByte[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="SByte"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="SByte"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(SByte[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="SByte"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(SByte[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="SByte"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(SByte[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="UInt16"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public unsafe void Update(UInt16 message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(UInt16) - 1)) == 0) && _remainder + sizeof(UInt16) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(UInt16*)((byte*)uptr + _remainder) = message;
                _length += sizeof(UInt16);
                _remainder += sizeof(UInt16);
            }
            else
                Update(&message, sizeof(UInt16));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="UInt16"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="UInt16"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        public void Update(UInt16[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(UInt16[] message, int startIndex, int length)
        {
            fixed(UInt16* ptr = message)
                Update(ptr + startIndex, length * sizeof(UInt16));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="UInt16"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(UInt16[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{UInt16}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(IEnumerable<UInt16> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as UInt16[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<UInt16> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(UInt16[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(UInt16* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(UInt16), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt16"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt16"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt16[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt16"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt16"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt16[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt16"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt16"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt16[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt16"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt16[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(UInt16[] message, int startIndex, int length, ulong seed)
        {
            fixed(UInt16* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(UInt16), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt16"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt16"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt16[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt16"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt16"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt16[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt16"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt16[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt16"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt16[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(UInt16[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt16"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt16"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt16[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt16"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt16"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt16[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt16"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt16[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt16"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt16[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="UInt32"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public unsafe void Update(UInt32 message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(UInt32) - 1)) == 0) && _remainder + sizeof(UInt32) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(UInt32*)((byte*)uptr + _remainder) = message;
                _length += sizeof(UInt32);
                _remainder += sizeof(UInt32);
            }
            else
                Update(&message, sizeof(UInt32));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="UInt32"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="UInt32"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        public void Update(UInt32[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(UInt32[] message, int startIndex, int length)
        {
            fixed(UInt32* ptr = message)
                Update(ptr + startIndex, length * sizeof(UInt32));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="UInt32"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(UInt32[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{UInt32}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(IEnumerable<UInt32> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as UInt32[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<UInt32> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(UInt32[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(UInt32* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(UInt32), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt32"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt32"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt32[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt32"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt32"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt32[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt32"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt32"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt32[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt32"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt32[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(UInt32[] message, int startIndex, int length, ulong seed)
        {
            fixed(UInt32* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(UInt32), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt32"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt32"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt32[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt32"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt32"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt32[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt32"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt32[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt32"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt32[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(UInt32[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt32"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt32"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt32[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt32"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt32"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt32[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt32"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt32[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt32"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt32[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="UInt64"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public unsafe void Update(UInt64 message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(UInt64) - 1)) == 0) && _remainder + sizeof(UInt64) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(UInt64*)((byte*)uptr + _remainder) = message;
                _length += sizeof(UInt64);
                _remainder += sizeof(UInt64);
            }
            else
                Update(&message, sizeof(UInt64));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="UInt64"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="UInt64"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        public void Update(UInt64[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(UInt64[] message, int startIndex, int length)
        {
            fixed(UInt64* ptr = message)
                Update(ptr + startIndex, length * sizeof(UInt64));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="UInt64"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(UInt64[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{UInt64}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        [CLSCompliant(false)]
        public void Update(IEnumerable<UInt64> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as UInt64[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<UInt64> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(UInt64[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(UInt64* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(UInt64), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt64"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt64"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt64[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt64"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt64"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt64[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt64"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt64"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt64[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="UInt64"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(UInt64[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(UInt64[] message, int startIndex, int length, ulong seed)
        {
            fixed(UInt64* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(UInt64), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt64"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt64"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt64[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt64"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt64"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt64[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt64"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt64[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="UInt64"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static long SpookyHash64(UInt64[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(UInt64[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt64"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt64"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt64[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt64"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="UInt64"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt64[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt64"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt64[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="UInt64"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static int SpookyHash32(UInt64[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="Byte"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [SecuritySafeCritical]
        public unsafe void Update(Byte message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(Byte) - 1)) == 0) && _remainder + sizeof(Byte) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(Byte*)((byte*)uptr + _remainder) = message;
                _length += sizeof(Byte);
                _remainder += sizeof(Byte);
            }
            else
                Update(&message, sizeof(Byte));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Byte"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="Byte"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        public void Update(Byte[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(Byte[] message, int startIndex, int length)
        {
            fixed(Byte* ptr = message)
                Update(ptr + startIndex, length * sizeof(Byte));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Byte"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(Byte[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{Byte}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(IEnumerable<Byte> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as Byte[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<Byte> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(Byte[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(Byte* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(Byte), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Byte"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Byte"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Byte[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Byte"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Byte"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Byte[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Byte"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Byte"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Byte[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Byte"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Byte[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(Byte[] message, int startIndex, int length, ulong seed)
        {
            fixed(Byte* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(Byte), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Byte"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Byte"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Byte[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Byte"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Byte"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Byte[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Byte"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Byte[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Byte"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Byte[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(Byte[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Byte"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Byte"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Byte[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Byte"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Byte"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Byte[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Byte"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Byte[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Byte"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Byte[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="Char"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [SecuritySafeCritical]
        public unsafe void Update(Char message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(Char) - 1)) == 0) && _remainder + sizeof(Char) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(Char*)((byte*)uptr + _remainder) = message;
                _length += sizeof(Char);
                _remainder += sizeof(Char);
            }
            else
                Update(&message, sizeof(Char));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Char"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="Char"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        public void Update(Char[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(Char[] message, int startIndex, int length)
        {
            fixed(Char* ptr = message)
                Update(ptr + startIndex, length * sizeof(Char));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Char"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(Char[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{Char}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(IEnumerable<Char> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as Char[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<Char> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(Char[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(Char* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(Char), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Char"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Char"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Char[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Char"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Char"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Char[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Char"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Char"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Char[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Char"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Char[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(Char[] message, int startIndex, int length, ulong seed)
        {
            fixed(Char* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(Char), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Char"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Char"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Char[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Char"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Char"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Char[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Char"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Char[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Char"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Char[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(Char[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Char"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Char"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Char[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Char"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Char"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Char[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Char"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Char[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Char"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Char[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="Int16"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [SecuritySafeCritical]
        public unsafe void Update(Int16 message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(Int16) - 1)) == 0) && _remainder + sizeof(Int16) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(Int16*)((byte*)uptr + _remainder) = message;
                _length += sizeof(Int16);
                _remainder += sizeof(Int16);
            }
            else
                Update(&message, sizeof(Int16));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Int16"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="Int16"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        public void Update(Int16[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(Int16[] message, int startIndex, int length)
        {
            fixed(Int16* ptr = message)
                Update(ptr + startIndex, length * sizeof(Int16));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Int16"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(Int16[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{Int16}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(IEnumerable<Int16> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as Int16[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<Int16> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(Int16[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(Int16* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(Int16), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int16"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int16"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int16[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int16"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int16"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int16[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int16"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int16"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int16[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int16"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int16[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(Int16[] message, int startIndex, int length, ulong seed)
        {
            fixed(Int16* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(Int16), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int16"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int16"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int16[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int16"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int16"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int16[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int16"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int16[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int16"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int16[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(Int16[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int16"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int16"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int16[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int16"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int16"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int16[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int16"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int16[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int16"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int16[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="Int32"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [SecuritySafeCritical]
        public unsafe void Update(Int32 message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(Int32) - 1)) == 0) && _remainder + sizeof(Int32) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(Int32*)((byte*)uptr + _remainder) = message;
                _length += sizeof(Int32);
                _remainder += sizeof(Int32);
            }
            else
                Update(&message, sizeof(Int32));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Int32"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="Int32"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        public void Update(Int32[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(Int32[] message, int startIndex, int length)
        {
            fixed(Int32* ptr = message)
                Update(ptr + startIndex, length * sizeof(Int32));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Int32"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(Int32[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{Int32}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(IEnumerable<Int32> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as Int32[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<Int32> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(Int32[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(Int32* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(Int32), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int32"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int32"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int32[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int32"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int32"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int32[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int32"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int32"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int32[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int32"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int32[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(Int32[] message, int startIndex, int length, ulong seed)
        {
            fixed(Int32* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(Int32), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int32"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int32"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int32[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int32"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int32"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int32[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int32"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int32[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int32"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int32[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(Int32[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int32"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int32"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int32[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int32"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int32"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int32[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int32"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int32[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int32"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int32[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="Int64"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [SecuritySafeCritical]
        public unsafe void Update(Int64 message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(Int64) - 1)) == 0) && _remainder + sizeof(Int64) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(Int64*)((byte*)uptr + _remainder) = message;
                _length += sizeof(Int64);
                _remainder += sizeof(Int64);
            }
            else
                Update(&message, sizeof(Int64));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Int64"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="Int64"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        public void Update(Int64[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(Int64[] message, int startIndex, int length)
        {
            fixed(Int64* ptr = message)
                Update(ptr + startIndex, length * sizeof(Int64));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Int64"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(Int64[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{Int64}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(IEnumerable<Int64> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as Int64[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<Int64> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(Int64[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(Int64* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(Int64), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int64"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int64"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int64[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int64"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int64"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int64[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int64"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int64"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int64[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Int64"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Int64[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(Int64[] message, int startIndex, int length, ulong seed)
        {
            fixed(Int64* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(Int64), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int64"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int64"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int64[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int64"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int64"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int64[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int64"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int64[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Int64"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Int64[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(Int64[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int64"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int64"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int64[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int64"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Int64"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int64[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int64"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int64[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Int64"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Int64[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="Single"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [SecuritySafeCritical]
        public unsafe void Update(Single message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(Single) - 1)) == 0) && _remainder + sizeof(Single) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(Single*)((byte*)uptr + _remainder) = message;
                _length += sizeof(Single);
                _remainder += sizeof(Single);
            }
            else
                Update(&message, sizeof(Single));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Single"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="Single"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        public void Update(Single[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(Single[] message, int startIndex, int length)
        {
            fixed(Single* ptr = message)
                Update(ptr + startIndex, length * sizeof(Single));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Single"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(Single[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{Single}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(IEnumerable<Single> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as Single[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<Single> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(Single[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(Single* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(Single), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Single"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Single"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Single[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Single"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Single"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Single[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Single"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Single"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Single[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Single"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Single[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(Single[] message, int startIndex, int length, ulong seed)
        {
            fixed(Single* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(Single), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Single"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Single"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Single[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Single"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Single"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Single[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Single"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Single[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Single"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Single[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(Single[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Single"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Single"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Single[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Single"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Single"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Single[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Single"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Single[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Single"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Single[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="Double"/>.</summary>
        /// <param name="message">The data to add to the hash.</param>
        [SecuritySafeCritical]
        public unsafe void Update(Double message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(Double) - 1)) == 0) && _remainder + sizeof(Double) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(Double*)((byte*)uptr + _remainder) = message;
                _length += sizeof(Double);
                _remainder += sizeof(Double);
            }
            else
                Update(&message, sizeof(Double));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Double"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="Double"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        public void Update(Double[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(Double[] message, int startIndex, int length)
        {
            fixed(Double* ptr = message)
                Update(ptr + startIndex, length * sizeof(Double));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="Double"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(Double[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{Double}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        public void Update(IEnumerable<Double> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as Double[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<Double> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(Double[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(Double* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(Double), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Double"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Double"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Double[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Double"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Double"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Double[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Double"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Double"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Double[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="Double"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(Double[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(Double[] message, int startIndex, int length, ulong seed)
        {
            fixed(Double* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(Double), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Double"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Double"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Double[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Double"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Double"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static long SpookyHash64(Double[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Double"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Double[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="Double"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static long SpookyHash64(Double[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(Double[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Double"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Double"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Double[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Double"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="Double"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> was less than zero, or greater
        /// than the length of the array.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [SecuritySafeCritical]
        public static int SpookyHash32(Double[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Double"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Double[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="Double"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        [SecuritySafeCritical]
        public static int SpookyHash32(Double[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
    public sealed partial class SpookyHash
    {
        /// <summary>Calculates the 128-bit SpookyHash for a message.</summary>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed1">First 64 bits of the seed.</param>
        /// <param name="seed2">Second 64 bits of the seed.</param>
        /// <returns><see cref="HashCode128"/> representing the 128-bit hash.</returns>
        [CLSCompliant(false)]
        [SecurityCritical]
        [SuppressMessage("Microsoft.Security", "CA2116:AptcaMethodsShouldOnlyCallAptcaMethods",
            Justification = "Method already protected by SecurityCritical")]
        public static unsafe HashCode128 Hash128(UIntPtr message, int length, ulong seed1, ulong seed2)
        {
            ulong hash1 = (ulong)seed1;
            ulong hash2 = (ulong)seed2;
            Hash128((void*)message, length, ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Calculates the 64-bit SpookyHash for a message.</summary>
        /// <returns>The 64-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [CLSCompliant(false)]
        [SecurityCritical]
        public static unsafe ulong Hash64(UIntPtr message, int length, ulong seed)
        {
            return unchecked((ulong)Hash64((void*)message, length, (ulong)seed));
        }

        /// <summary>Calculates a 32-bit SpookyHash for a message.</summary>
        /// <returns>The 32-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [CLSCompliant(false)]
        [SecurityCritical]
        public static unsafe uint Hash32(UIntPtr message, int length, uint seed)
        {
            return unchecked((uint)Hash64(message, length, (uint)seed));
        }
        /// <summary>Calculates the 128-bit SpookyHash for a message.</summary>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed1">First 64 bits of the seed.</param>
        /// <param name="seed2">Second 64 bits of the seed.</param>
        /// <returns><see cref="HashCode128"/> representing the 128-bit hash.</returns>
        [CLSCompliant(false)]
        [SecurityCritical]
        [SuppressMessage("Microsoft.Security", "CA2116:AptcaMethodsShouldOnlyCallAptcaMethods",
            Justification = "Method already protected by SecurityCritical")]
        public static unsafe HashCode128 Hash128(UIntPtr message, int length, long seed1, long seed2)
        {
            ulong hash1 = (ulong)seed1;
            ulong hash2 = (ulong)seed2;
            Hash128((void*)message, length, ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Calculates the 64-bit SpookyHash for a message.</summary>
        /// <returns>The 64-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [CLSCompliant(false)]
        [SecurityCritical]
        public static unsafe long Hash64(UIntPtr message, int length, long seed)
        {
            return unchecked((long)Hash64((void*)message, length, (ulong)seed));
        }

        /// <summary>Calculates a 32-bit SpookyHash for a message.</summary>
        /// <returns>The 32-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [CLSCompliant(false)]
        [SecurityCritical]
        public static unsafe int Hash32(UIntPtr message, int length, int seed)
        {
            return unchecked((int)Hash64(message, length, (uint)seed));
        }
        /// <summary>Calculates the 128-bit SpookyHash for a message.</summary>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed1">First 64 bits of the seed.</param>
        /// <param name="seed2">Second 64 bits of the seed.</param>
        /// <returns><see cref="HashCode128"/> representing the 128-bit hash.</returns>
        [CLSCompliant(false)]
        [SecurityCritical]
        [SuppressMessage("Microsoft.Security", "CA2116:AptcaMethodsShouldOnlyCallAptcaMethods",
            Justification = "Method already protected by SecurityCritical")]
        public static unsafe HashCode128 Hash128(IntPtr message, int length, ulong seed1, ulong seed2)
        {
            ulong hash1 = (ulong)seed1;
            ulong hash2 = (ulong)seed2;
            Hash128((void*)message, length, ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Calculates the 64-bit SpookyHash for a message.</summary>
        /// <returns>The 64-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [CLSCompliant(false)]
        [SecurityCritical]
        public static unsafe ulong Hash64(IntPtr message, int length, ulong seed)
        {
            return unchecked((ulong)Hash64((void*)message, length, (ulong)seed));
        }

        /// <summary>Calculates a 32-bit SpookyHash for a message.</summary>
        /// <returns>The 32-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [CLSCompliant(false)]
        [SecurityCritical]
        public static unsafe uint Hash32(IntPtr message, int length, uint seed)
        {
            return unchecked((uint)Hash64(message, length, (uint)seed));
        }
        /// <summary>Calculates the 128-bit SpookyHash for a message.</summary>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed1">First 64 bits of the seed.</param>
        /// <param name="seed2">Second 64 bits of the seed.</param>
        /// <returns><see cref="HashCode128"/> representing the 128-bit hash.</returns>
        [SecurityCritical]
        [SuppressMessage("Microsoft.Security", "CA2116:AptcaMethodsShouldOnlyCallAptcaMethods",
            Justification = "Method already protected by SecurityCritical")]
        public static unsafe HashCode128 Hash128(IntPtr message, int length, long seed1, long seed2)
        {
            ulong hash1 = (ulong)seed1;
            ulong hash2 = (ulong)seed2;
            Hash128((void*)message, length, ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Calculates the 64-bit SpookyHash for a message.</summary>
        /// <returns>The 64-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [SecurityCritical]
        public static unsafe long Hash64(IntPtr message, int length, long seed)
        {
            return unchecked((long)Hash64((void*)message, length, (ulong)seed));
        }

        /// <summary>Calculates a 32-bit SpookyHash for a message.</summary>
        /// <returns>The 32-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception>
        [SecurityCritical]
        public static unsafe int Hash32(IntPtr message, int length, int seed)
        {
            return unchecked((int)Hash64(message, length, (uint)seed));
        }
  }
}