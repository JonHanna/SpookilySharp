<#@ template language="C#" #>
<#@ output extension=".generated.cs" #>
<#
// SpookyHashOverloads.tt
//
// Author:
//     Jon Hanna <jon@hackcraft.net>
//
// © 2014 Jon Hanna
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.
#>
// SpookyHashOverloads.generated.cs
//
// Generated File. DO NOT EDIT THIS FILE. Edit SpookyHashOverloads.tt to change the produced file.
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Security;

namespace SpookilySharp
{
<#
    Type[] types = {typeof(sbyte), typeof(ushort), typeof(uint), typeof(ulong), typeof(byte), typeof(char), typeof(short), typeof(int), typeof(long), typeof(float), typeof(double)};
    for(int i = 0; i != types.Length; ++i)
    {
        Type type = types[i];
        string name = type.Name;
        string clsAttr = i < 4 ? "\n        [CLSCompliant(false)]" : "";
#>
    public sealed partial class SpookyHash
    {
        /// <summary>Updates the in-progress hash generation with a single <see cref="<#=name#>"/>.</summary>
        /// <param name="message">The data to add to the hash.</param><#=clsAttr#>
        [SecuritySafeCritical]
        public unsafe void Update(<#=name#> message)
        {
            if((AllowUnalignedRead || (_remainder & (sizeof(<#=name#>) - 1)) == 0) && _remainder + sizeof(<#=name#>) < BufSize)
            {
                fixed(ulong* uptr = _data)
                    *(<#=name#>*)((byte*)uptr + _remainder) = message;
                _length += sizeof(<#=name#>);
                _remainder += sizeof(<#=name#>);
            }
            else
                Update(&message, sizeof(<#=name#>));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="<#=name#>"/>s to hash.</param>
        /// <param name="startIndex">Start index in the array, from which to hash.</param>
        /// <param name="length">How many <see cref="<#=name#>"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception><#=clsAttr#>
        public void Update(<#=name#>[] message, int startIndex, int length)
        {
            ExceptionHelper.CheckArrayIncNull(message, startIndex, length);
            UpdateUnchecked(message, startIndex, length);
        }
        
        [SecuritySafeCritical]
        private unsafe void UpdateUnchecked(<#=name#>[] message, int startIndex, int length)
        {
            fixed(<#=name#>* ptr = message)
                Update(ptr + startIndex, length * sizeof(<#=name#>));
        }

        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message"><see cref="<#=name#>"/>s to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception><#=clsAttr#>
        public void Update(<#=name#>[] message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            UpdateUnchecked(message, 0, message.Length);
        }
        
        /// <summary>Updates the in-progress hash generation with more of the message.</summary>
        /// <param name="message">An <see cref="IEnumerable{<#=name#>}"/> of items to hash.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> was null.</exception><#=clsAttr#>
        public void Update(IEnumerable<<#=name#>> message)
        {
            ExceptionHelper.CheckMessageNotNull(message);
            var asArr = message as <#=name#>[];
            if(asArr != null)
                UpdateUnchecked(asArr, 0, asArr.Length);
            else
                UpdateEnumerable(message);
        }
        private void UpdateEnumerable(IEnumerable<<#=name#>> message)
        {
            foreach(var item in message)
                Update(item);
        }
    }

    public static partial class SpookyHasher
    {
        [SecurityCritical]
        private static unsafe HashCode128 SpookyHash128Unchecked(<#=name#>[] message, int startIndex, int length, ulong hash1, ulong hash2)
        {
            fixed(<#=name#>* ptr = message)
                SpookyHash.Hash128(ptr + startIndex, length * sizeof(<#=name#>), ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="<#=name#>"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="<#=name#>"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception><#=clsAttr#>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(this <#=name#>[] message, int startIndex, int length, long seed0, long seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash128Unchecked(message, startIndex, length, (ulong)seed0, (ulong)seed1));
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="<#=name#>"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="<#=name#>"/>s to hash.</param>
        /// <param name="seed0">The first 64-bits of the seed value.</param>
        /// <param name="seed1">The second 64-bits of the seed value.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(this <#=name#>[] message, int startIndex, int length, ulong seed0, ulong seed1)
        {
            if(message == null)
                return default(HashCode128);
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash128Unchecked(message, startIndex, length, seed0, seed1);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="<#=name#>"/>s, with a default seed.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="<#=name#>"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception><#=clsAttr#>
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(this <#=name#>[] message, int startIndex, int length)
        {
            return SpookyHash128(message, startIndex, length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        /// <summary>Produces an 128-bit SpookyHash of an array of <see cref="<#=name#>"/>s.</summary>
        /// <returns>A <see cref="HashCode128"/> containing the two 64-bit halves of the 128-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be <see cref="HashCode128.Zero"/> .</remarks>
        [CLSCompliant(false)]
        [SecuritySafeCritical]
        public static HashCode128 SpookyHash128(this <#=name#>[] message)
        {
            return message == null
                ? default(HashCode128)
                : SpookyHash128Unchecked(message, 0, message.Length, SpookyHash.SpookyConst, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static unsafe long SpookyHash64Unchecked(this <#=name#>[] message, int startIndex, int length, ulong seed)
        {
            fixed(<#=name#>* ptr = message)
                return (long)SpookyHash.Hash64(ptr + startIndex, length * sizeof(<#=name#>), seed);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="<#=name#>"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="<#=name#>"/>s to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception><#=clsAttr#>
        [SecuritySafeCritical]
        public static long SpookyHash64(this <#=name#>[] message, int startIndex, int length, long seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash64Unchecked(message, startIndex, length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="<#=name#>"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="<#=name#>"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception><#=clsAttr#>
        [SecuritySafeCritical]
        public static long SpookyHash64(this <#=name#>[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return SpookyHash64Unchecked(message, startIndex, length, SpookyHash.SpookyConst);
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="<#=name#>"/>s.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 64-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks><#=clsAttr#>
        [SecuritySafeCritical]
        public static long SpookyHash64(this <#=name#>[] message, long seed)
        {
            return message == null ? 0 : unchecked(SpookyHash64Unchecked(message, 0, message.Length, (ulong)seed));
        }

        /// <summary>Produces a 64-bit SpookyHash of an array of <see cref="<#=name#>"/>s, using a default seed.</summary>
        /// <returns>A <see cref="long"/> containing the 64-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks><#=clsAttr#>
        [SecuritySafeCritical]
        public static long SpookyHash64(this <#=name#>[] message)
        {
            return message == null ? 0 : SpookyHash64Unchecked(message, 0, message.Length, SpookyHash.SpookyConst);
        }

        [SecurityCritical]
        private static int SpookyHash32Unchecked(<#=name#>[] message, int startIndex, int length, uint seed)
        {
            return unchecked((int)SpookyHash64Unchecked(message, startIndex, length, seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="<#=name#>"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="<#=name#>"/>s to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception><#=clsAttr#>
        [SecuritySafeCritical]
        public static int SpookyHash32(this <#=name#>[] message, int startIndex, int length, int seed)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="<#=name#>"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="startIndex">The index from which to hash.</param>
        /// <param name="length">The number of <see cref="<#=name#>"/>s to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero, or greater
        /// than the length of the array, or <paramref name="length"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><paramref name="startIndex"/> plus <paramref name="length"/> is greater
        /// than the length of the array.</exception><#=clsAttr#>
        [SecuritySafeCritical]
        public static int SpookyHash32(this <#=name#>[] message, int startIndex, int length)
        {
            if(message == null)
                return 0;
            ExceptionHelper.CheckArray(message, startIndex, length);
            return unchecked(SpookyHash32Unchecked(message, startIndex, length, (uint)SpookyHash.SpookyConst));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="<#=name#>"/>s.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <param name="seed">The 32-bit seed value.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks><#=clsAttr#>
        [SecuritySafeCritical]
        public static int SpookyHash32(this <#=name#>[] message, int seed)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)seed));
        }

        /// <summary>Produces a 32-bit SpookyHash of an array of <see cref="<#=name#>"/>s, using a default seed.</summary>
        /// <returns>An <see cref="int"/> containing the two 32-bit hash.</returns>
        /// <param name="message">The array to hash.</param>
        /// <remarks>For a null array, the hash will be zero.</remarks><#=clsAttr#>
        [SecuritySafeCritical]
        public static int SpookyHash32(this <#=name#>[] message)
        {
            return message == null ? 0 : unchecked(SpookyHash32Unchecked(message, 0, message.Length, (uint)SpookyHash.SpookyConst));
        }
    }
<#
}
#>
    public sealed partial class SpookyHash
    {
<#
    foreach(string pPref in new []{"U", ""})
        foreach(string sPref in new []{"u", ""})
        {
            string clsAttr = pPref.Length != 0 || sPref.Length != 0 ? "\n        [CLSCompliant(false)]" : "";
#>
        /// <summary>Calculates the 128-bit SpookyHash for a message.</summary>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed1">First 64 bits of the seed.</param>
        /// <param name="seed2">Second 64 bits of the seed.</param>
        /// <returns><see cref="HashCode128"/> representing the 128-bit hash.</returns><#=clsAttr#>
        [SecurityCritical]
        [SuppressMessage("Microsoft.Security", "CA2116:AptcaMethodsShouldOnlyCallAptcaMethods",
            Justification = "Method already protected by SecurityCritical")]
        public static unsafe HashCode128 Hash128(<#=pPref#>IntPtr message, int length, <#=sPref#>long seed1, <#=sPref#>long seed2)
        {
            ulong hash1 = (ulong)seed1;
            ulong hash2 = (ulong)seed2;
            Hash128((void*)message, length, ref hash1, ref hash2);
            return new HashCode128(hash1, hash2);
        }

        /// <summary>Calculates the 64-bit SpookyHash for a message.</summary>
        /// <returns>The 64-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception><#=clsAttr#>
        [SecurityCritical]
        public static unsafe <#=sPref#>long Hash64(<#=pPref#>IntPtr message, int length, <#=sPref#>long seed)
        {
            return unchecked((<#=sPref#>long)Hash64((void*)message, length, (ulong)seed));
        }

        /// <summary>Calculates a 32-bit SpookyHash for a message.</summary>
        /// <returns>The 32-bit hash.</returns>
        /// <param name="message">Pointer to the first element to hash.</param>
        /// <param name="length">The size, in bytes, of the elements to hash.</param>
        /// <param name="seed">A seed for the hash.</param>
        /// <exception cref="AccessViolationException">This is an unsafe method. If you attempt to read past the buffer
        /// that <paramref name="message"/> points too, you may raise an <see cref="AccessViolationException"/>, or you
        /// may have incorrect results.</exception><#=clsAttr#>
        [SecurityCritical]
        public static unsafe <#=sPref#>int Hash32(<#=pPref#>IntPtr message, int length, <#=sPref#>int seed)
        {
            return unchecked((<#=sPref#>int)Hash64(message, length, (uint)seed));
        }
<#
        }
#>  }
}