<#@ template language="C#" #>
<#@ output extension=".generated.cs" #>
<#
// Overloads.tt
//
// Author:
//     Jon Hanna <jon@hackcraft.net>
//
// © 2014 Jon Hanna
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.
#>
// Overloads.generated.cs
//
// Generated File. DO NOT EDIT THIS FILE. Edit Overloads.tt to change the produced file.
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.

using System;
using System.Collections.Generic;
using System.Linq;
using SpookilySharp;
using Xunit;

namespace SpookyHashTesting
{
<#
    Type[] types = {typeof(sbyte), typeof(ushort), typeof(uint), typeof(ulong), typeof(byte), typeof(char), typeof(short), typeof(int), typeof(long), typeof(float), typeof(double)};
    for(int i = 0; i != types.Length; ++i)
    {
        Type type = types[i];
        string name = type.Name;
#>
	public sealed partial class HashUpdateTests
	{
        [Fact]
        public unsafe void UpdateWith<#=name#>()
        {
            <#=name#> val = (<#=name#>)42;
            var sh = new SpookyHash();
            sh.Update(val);
            var h = sh.Final();
            sh = new SpookyHash();
            sh.Update(&val, sizeof(<#=name#>));
            Assert.Equal(h, sh.Final());
            sh = new SpookyHash();
            for(int i = 0; i != 200; ++i)
                sh.Update((<#=name#>)i);
            h = sh.Final();
            sh = new SpookyHash();
            var arr = new <#=name#>[200];
            for(int i = 0; i != 200; ++i)
                arr[i] = (<#=name#>)i;
            sh.Update(arr);
            Assert.Equal(h, sh.Final());
            sh = new SpookyHash();
            sh.Update(arr, 0, 200);
            Assert.Equal(h, sh.Final());
            sh = new SpookyHash();
            sh.Update((IEnumerable<<#=name#>>)arr);
            sh = new SpookyHash();
            sh.Update(arr.Select(i => i));
        }
        [Fact]
        public void Null<#=name#>ArrayUpdate()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentNullException>(() => hash.Update((<#=name#>[])null));
        }

        [Fact]
        public void Null<#=name#>ArrayWithLength()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentNullException>(() => hash.Update((<#=name#>[])null, 0, 0));
        }

        [Fact]
        public void NegativeOffest<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentOutOfRangeException>(() => hash.Update(new <#=name#>[0], -1, 2));
        }

        [Fact]
        public void ExcessiveOffest<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentOutOfRangeException>(() => hash.Update(new <#=name#>[0], 40, 2));
        }

        [Fact]
        public void ExcessiveLength<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentException>(() => hash.Update(new <#=name#>[]{default(<#=name#>)}, 0, 2));
        }

        [Fact]
        public void NegativeLength<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentOutOfRangeException>(() => hash.Update(new <#=name#>[0], 0, -2));
        }
    }

    public sealed partial class HasherTests
    {
        [Fact]
        public void ArrayExtension<#=name#>()
        {
            var arr = new <#=name#>[200];
            for(int i = 0; i != arr.Length; ++i)
                arr[i] = (<#=name#>)i;
            var sh = new SpookyHash();
            sh.Update(arr);
            var h = sh.Final();
            Assert.Equal(h, SpookyHasher.SpookyHash128(arr));
            Assert.Equal(h, SpookyHasher.SpookyHash128(arr, 0, 200, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF));
            Assert.Equal(h, unchecked(SpookyHasher.SpookyHash128(arr, 0, 200, (long)0xDEADBEEFDEADBEEF, (long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(h, SpookyHasher.SpookyHash128(arr, 0, 200));
            var hSlice = SpookyHasher.SpookyHash128(arr, 50, 100, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF);
            Assert.NotEqual(h, hSlice);
            Assert.Equal(hSlice, unchecked(SpookyHasher.SpookyHash128(arr, 50, 100, (long)0xDEADBEEFDEADBEEF, (long)0xDEADBEEFDEADBEEF)));
            long lHash = SpookyHasher.SpookyHash64(arr, 0, 200, unchecked((long)0xDEADBEEFDEADBEEF));
            Assert.Equal(lHash, SpookyHasher.SpookyHash64(arr, unchecked((long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(lHash, SpookyHasher.SpookyHash64(arr, 0, 200));
            Assert.Equal(lHash, SpookyHasher.SpookyHash64(arr));
            int hash = SpookyHasher.SpookyHash32(arr, 0, 200, unchecked((int)0xDEADBEEF));
            Assert.Equal(hash, SpookyHasher.SpookyHash32(arr, unchecked((int)0xDEADBEEF)));
            Assert.Equal(hash, SpookyHasher.SpookyHash32(arr, 0, 200));
            Assert.Equal(hash, SpookyHasher.SpookyHash32(arr));
            arr = null;
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr));
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr, 0, 200, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF));
            Assert.Equal(HashCode128.Zero, unchecked(SpookyHasher.SpookyHash128(arr, 0, 200, (long)0xDEADBEEFDEADBEEF, (long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr, 0, 200));
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr, 50, 100, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr, 0, 200, unchecked((long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr, unchecked((long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr, 0, 200));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr, 0, 200, unchecked((int)0xDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr, unchecked((int)0xDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr, 0, 200));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr));
        }
        <#foreach(int size in new []{32, 64, 128})
        {
#>

        [Fact]
        public void NegativeOffest<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentOutOfRangeException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[0], -1, 2));
        }

        [Fact]
        public void ExcessiveOffest<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentOutOfRangeException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[0], 40, 2));
        }

        [Fact]
        public void ExcessiveLength<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[]{default(<#=name#>)}, 0, 2));
        }

        [Fact]
        public void NegativeLength<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentOutOfRangeException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[0], 0, -2));
        }
        <#}#>
    }
<#}#>
}
