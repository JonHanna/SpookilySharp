<#@ template language="C#" #>
<#@ output extension=".generated.cs" #>
<#
// Overloads.tt
//
//
// Author:
//     Jon Hanna <jon@hackcraft.net>
//
// © 2014–2017 Jon Hanna
//
// Licensed under the MIT license. See the LICENSE file in the repository root for more details.
#>
// Overloads.generated.cs
//
// Generated File. DO NOT EDIT THIS FILE. Edit Overloads.tt to change the produced file.
//
// Licensed under the MIT license. See the LICENSE file in the repository root for more details.

using System;
using System.Collections.Generic;
using System.Linq;
using SpookilySharp;
using Xunit;

namespace SpookyHashTesting
{
<#
    Type[] types = {typeof(sbyte), typeof(ushort), typeof(uint), typeof(ulong), typeof(byte), typeof(char), typeof(short), typeof(int), typeof(long), typeof(float), typeof(double)};
    for(int i = 0; i != types.Length; ++i)
    {
        Type type = types[i];
        string name = type.Name;
#>
	public sealed partial class HashUpdateTests
	{
        [Fact]
        public unsafe void UpdateWith<#=name#>()
        {
            <#=name#> val = (<#=name#>)42;
            var sh = new SpookyHash();
            sh.Update(val);
            var h = sh.Final();
            sh = new SpookyHash();
            sh.Update(&val, sizeof(<#=name#>));
            Assert.Equal(h, sh.Final());
            sh = new SpookyHash();
            for(int i = 0; i != 200; ++i)
                sh.Update((<#=name#>)i);
            h = sh.Final();
            sh = new SpookyHash();
            var arr = new <#=name#>[200];
            for(int i = 0; i != 200; ++i)
                arr[i] = (<#=name#>)i;
            sh.Update(arr);
            Assert.Equal(h, sh.Final());
            sh = new SpookyHash();
            sh.Update(arr, 0, 200);
            Assert.Equal(h, sh.Final());
            sh = new SpookyHash();
            sh.Update((IEnumerable<<#=name#>>)arr);
            sh = new SpookyHash();
            sh.Update(arr.Select(i => i));
        }
        [Fact]
        public void Null<#=name#>ArrayUpdate()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentNullException>(() => hash.Update((<#=name#>[])null));
        }

        [Fact]
        public void Null<#=name#>ArrayWithLength()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentNullException>(() => hash.Update((<#=name#>[])null, 0, 0));
        }

        [Fact]
        public void NegativeOffest<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentOutOfRangeException>(() => hash.Update(new <#=name#>[0], -1, 2));
        }

        [Fact]
        public void ExcessiveOffest<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentOutOfRangeException>(() => hash.Update(new <#=name#>[0], 40, 2));
        }

        [Fact]
        public void ExcessiveLength<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentException>(() => hash.Update(new <#=name#>[]{default(<#=name#>)}, 0, 2));
        }

        [Fact]
        public void NegativeLength<#=name#>()
        {
            SpookyHash hash = new SpookyHash();
			Assert.Throws<ArgumentOutOfRangeException>(() => hash.Update(new <#=name#>[0], 0, -2));
        }
    }

    public sealed partial class HasherTests
    {
        [Fact]
        public void ArrayExtension<#=name#>()
        {
            var arr = new <#=name#>[200];
            for(int i = 0; i != arr.Length; ++i)
                arr[i] = (<#=name#>)i;
            var sh = new SpookyHash();
            sh.Update(arr);
            var h = sh.Final();
            Assert.Equal(h, SpookyHasher.SpookyHash128(arr));
            Assert.Equal(h, SpookyHasher.SpookyHash128(arr, 0, 200, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF));
            Assert.Equal(h, unchecked(SpookyHasher.SpookyHash128(arr, 0, 200, (long)0xDEADBEEFDEADBEEF, (long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(h, SpookyHasher.SpookyHash128(arr, 0, 200));
            var hSlice = SpookyHasher.SpookyHash128(arr, 50, 100, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF);
            Assert.NotEqual(h, hSlice);
            Assert.Equal(hSlice, unchecked(SpookyHasher.SpookyHash128(arr, 50, 100, (long)0xDEADBEEFDEADBEEF, (long)0xDEADBEEFDEADBEEF)));
            long lHash = SpookyHasher.SpookyHash64(arr, 0, 200, unchecked((long)0xDEADBEEFDEADBEEF));
            Assert.Equal(lHash, SpookyHasher.SpookyHash64(arr, unchecked((long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(lHash, SpookyHasher.SpookyHash64(arr, 0, 200));
            Assert.Equal(lHash, SpookyHasher.SpookyHash64(arr));
            int hash = SpookyHasher.SpookyHash32(arr, 0, 200, unchecked((int)0xDEADBEEF));
            Assert.Equal(hash, SpookyHasher.SpookyHash32(arr, unchecked((int)0xDEADBEEF)));
            Assert.Equal(hash, SpookyHasher.SpookyHash32(arr, 0, 200));
            Assert.Equal(hash, SpookyHasher.SpookyHash32(arr));
            arr = null;
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr));
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr, 0, 200, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF));
            Assert.Equal(HashCode128.Zero, unchecked(SpookyHasher.SpookyHash128(arr, 0, 200, (long)0xDEADBEEFDEADBEEF, (long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr, 0, 200));
            Assert.Equal(HashCode128.Zero, SpookyHasher.SpookyHash128(arr, 50, 100, 0xDEADBEEFDEADBEEF, 0xDEADBEEFDEADBEEF));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr, 0, 200, unchecked((long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr, unchecked((long)0xDEADBEEFDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr, 0, 200));
            Assert.Equal(0, SpookyHasher.SpookyHash64(arr));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr, 0, 200, unchecked((int)0xDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr, unchecked((int)0xDEADBEEF)));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr, 0, 200));
            Assert.Equal(0, SpookyHasher.SpookyHash32(arr));
        }
        <#foreach(int size in new []{32, 64, 128})
        {
#>

        [Fact]
        public void NegativeOffest<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentOutOfRangeException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[0], -1, 2));
        }

        [Fact]
        public void ExcessiveOffest<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentOutOfRangeException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[0], 40, 2));
        }

        [Fact]
        public void ExcessiveLength<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[]{default(<#=name#>)}, 0, 2));
        }

        [Fact]
        public void NegativeLength<#=size#><#=name#>()
        {
            Assert.Throws<ArgumentOutOfRangeException>(() => SpookyHasher.SpookyHash<#=size#>(new <#=name#>[0], 0, -2));
        }
        <#}#>
    }
<#}#>
}
